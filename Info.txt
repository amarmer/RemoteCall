RemoteCall is C++ framework for RPC.

There are many ways to use RPC, as it is described in http://en.wikipedia.org/wiki/Remote_procedure_call, 
for instance XML-RPC, JSON-RPC, Protocol Buffers (protobufs), DCOM, CORBA, etc.

RemoteCall framework doesn't implement remote transport, it can use any synchronous remote transport 
which sends and receives array of bytes, for instance: http(s), tcp/ip, named pipes, etc.

RemoteCall automatically:
1. serializes parameters to byte array on the client
2. using any remote transport, sends serialized byte array to the server
3. on the server, unserializes byte array to calling parameters
4. invokes corresponding function with calling parameters on the server
5. serializes 'Return' and 'Out' parameters to byte array
6. using remote transport receives serialized byte array back on the client from the server
7. on the client, unserializes byte array to 'Return' and to 'Out' calling parameters

Advantage of RemoteCall C++ framework is it declares, implements and calls remote functions identially 
to how C++ calls are used locally in the same process.

For declarations, implementations, calls are used corresponding macros:
DECLARE_REMOTE, IMPLEMENT_REMOTE, CALL_REMOTE.

For comparison, bellow are local and remote declarations, implementations and calls:

1. Declaration

Local
tuple<std::string, int> Test(std::vector<std::string>& vInOut, char c, const string& s);

Remote  (for return and parameters can be used any type, except pointer)
tuple<std::string, int> DECLARE_REMOTE(Test)(std::vector<std::string>& vInOut, char c, const string& s);


2. Implementation

Local
tuple<std::string, int> Test(std::vector<std::string>& vInOut, char c, const string& s);
{
   ...
   return ret;
}

Remote  (server implementation)     
tuple<std::string, int> IMPLEMENT_REMOTE(Test)(std::vector<std::string>& vInOut, char c, const string& s)
{
   ...
   return ret;
}


3. Call

Local
vector<string> vInOut = {"In1", "In2"};
auto ret = Test(vInOut, "A", Test");

Remote      
vector<string> vInOut = {"In1", "In2"};
auto ret = transport.CALL_REMOTE(Test)(vInOut, "A", Test");


4. Transport
    
'transport' above is object of a class which is derived from RemoteCall::Transport and
implements pure virtual function SendReceive, which can use any remote data transfer methods 
to send and receive vector<char>, for instance:

class RemoteCallTransport: public RemoteCall::Transport
{
public:   
   bool SendReceive(std::vector<char>& vChar) override   
   {         
      RemoteDataTransport(vChar);      

      /*
      RemoteDataTransport(vChar) can be any appropiate data transport, for instance: http, sockets, names pipes,  etc.,         
      which sends and receives 'vChar'.

      When 'vChar' is received by server, it should call RemoteCall::Server::CallFromClient(vChar), 
      which  unserializes vChar and calls  corresponding server function.
      After call RemoteCall::Server::CallFromClient(vChar), 'vChar' contains serialized 'Return' and 'Out' parameters.
      Then 'vChar' should be sent back  to the client as 'Out' parameter of RemoteDataTransport(vChar).
      */
    }
};

RemoteCallTransport transport;


5. Data Serialization

For every data "T", there are 2 serialization functions which needs to be implemented:

RemoteCall::SerializeWriter& operator << (RemoteCall::SerializeWriter& writer, const T& t)
{   
   ...   
   return writer;
}

RemoteCall::SerializeReader& operator >> (RemoteCall::SerializeReader& reader, T& t)
{
   ...
   return reader;
}

Serialization of basic C++ types, const char*, std::string, std::vector, std::tuple are implemented in RemoteCallSerializer.h.


For instance for a structure ABC, serialization implementation is bellow:

struct ABC
{
   ABC(const std::string& s = "", char c = 0) : s_(s), c_(c) {}

   std::string s_;
   char c_;
};


RemoteCall::SerializeWriter& operator << (RemoteCall::SerializeWriter& writer, const ABC& abc)
{
   writer << abc.s_ << abc.c_;

   return writer;
}

RemoteCall::SerializeReader& operator >> (RemoteCall::SerializeReader& reader, ABC& abc)
{
   reader >> abc.s_ >> abc.c_;

   return reader;
}

Example of a function declaration which uses ABC:  bool DECLARE_REMOTE(Test)(std::vector<ABC>& vABC);
